/**
 * gate command — Nemyo Gate: single-command validation gate.
 *
 * Runs all automation configs + Flutter widget tests in sequence.
 * Produces a consolidated markdown report and exits non-zero if anything fails.
 */
import { resolve, dirname } from 'path';
import { execSync } from 'child_process';
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { run } from '../../core/orchestrator.js';

interface GateStep {
  name: string;
  type: 'yaml' | 'flutter';
  config?: string;
  outSubDir?: string;
  testPath?: string;
  cwd?: string;
}

interface GateStepResult {
  name: string;
  verdict: 'PASS' | 'FAIL';
  runId: string | null;
  durationMs: number;
  flowCount: number;
  artifactDir: string | null;
  error: string | null;
}

const NEMYO_STEPS: GateStep[] = [
  {
    name: 'Nemyo Web Dashboard',
    type: 'yaml',
    config: 'nemyo-web.yaml',
    outSubDir: 'nemyo-web',
  },
  {
    name: 'NeoXten Website',
    type: 'yaml',
    config: 'neoxten-website.yaml',
    outSubDir: 'neoxten-website',
  },
  {
    name: 'Nemyo Extension (MV3)',
    type: 'yaml',
    config: 'nemyo-extension.yaml',
    outSubDir: 'nemyo-extension',
  },
  {
    name: 'Nemyo API Endpoints',
    type: 'yaml',
    config: 'nemyo-api.yaml',
    outSubDir: 'nemyo-api',
  },
  {
    name: 'Child App Widget Tests',
    type: 'flutter',
    testPath: 'test/pairing_screen_test.dart',
    cwd: '../kidguard_child_app',
  },
  {
    name: 'Parent App Widget Tests',
    type: 'flutter',
    testPath: 'test/widget_test.dart',
    cwd: '../kidguard-mobile-app',
  },
];

function generateReport(
  results: GateStepResult[],
  overallVerdict: 'PASS' | 'FAIL',
  totalMs: number,
): string {
  const now = new Date().toISOString();
  const passed = results.filter((r) => r.verdict === 'PASS').length;
  const failed = results.filter((r) => r.verdict === 'FAIL').length;

  let md = `# Nemyo Gate Report\n\n`;
  md += `**Verdict:** ${overallVerdict === 'PASS' ? 'PASS ✓' : 'FAIL ✗'}\n`;
  md += `**Timestamp:** ${now}\n`;
  md += `**Duration:** ${(totalMs / 1000).toFixed(1)}s\n`;
  md += `**Steps:** ${passed} passed, ${failed} failed, ${results.length} total\n\n`;
  md += `---\n\n`;
  md += `| # | Component | Verdict | Run ID | Duration | Flows | Artifacts |\n`;
  md += `|---|-----------|---------|--------|----------|-------|-----------|\n`;

  results.forEach((r, i) => {
    const verdict = r.verdict === 'PASS' ? 'PASS' : 'FAIL';
    const runId = r.runId ?? '—';
    const dur = `${(r.durationMs / 1000).toFixed(1)}s`;
    const flows = r.flowCount > 0 ? String(r.flowCount) : '—';
    const artifacts = r.artifactDir ?? '—';
    md += `| ${i + 1} | ${r.name} | ${verdict} | ${runId} | ${dur} | ${flows} | ${artifacts} |\n`;
  });

  if (failed > 0) {
    md += `\n---\n\n## Failures\n\n`;
    results
      .filter((r) => r.verdict === 'FAIL')
      .forEach((r) => {
        md += `### ${r.name}\n\n`;
        md += `\`\`\`\n${r.error ?? 'Unknown error'}\n\`\`\`\n\n`;
      });
  }

  md += `\n---\n\n`;
  md += `*Generated by NeoXten Automation Framework — Nemyo Gate*\n`;

  return md;
}

export async function gateCommand(opts: {
  preset?: string;
  outDir?: string;
}): Promise<void> {
  const preset = opts.preset ?? 'nemyo';
  if (preset !== 'nemyo') {
    console.error(`Unknown preset: ${preset}. Available: nemyo`);
    process.exit(2);
  }

  const outDir = resolve(process.cwd(), opts.outDir ?? '.neoxten-out');
  const frameworkRoot = process.cwd();
  const results: GateStepResult[] = [];
  const gateStart = Date.now();

  console.log(`\n  Nemyo Gate — running ${NEMYO_STEPS.length} validation steps\n`);

  for (const step of NEMYO_STEPS) {
    const stepStart = Date.now();
    console.log(`  [${results.length + 1}/${NEMYO_STEPS.length}] ${step.name}...`);

    if (step.type === 'yaml' && step.config) {
      try {
        const configPath = resolve(frameworkRoot, step.config);
        const stepOutDir = resolve(outDir, step.outSubDir ?? step.name);
        const { verdict, artifacts } = await run({ configPath, outDir: stepOutDir });

        const flowCount = verdict.logExcerpts
          ? verdict.logExcerpts.filter((l: string) => l.startsWith('Executing flow:')).length
          : 0;

        results.push({
          name: step.name,
          verdict: verdict.verdict as 'PASS' | 'FAIL',
          runId: verdict.runId,
          durationMs: Date.now() - stepStart,
          flowCount,
          artifactDir: artifacts.runDir,
          error: verdict.verdict === 'FAIL'
            ? verdict.logExcerpts?.slice(-1)[0] ?? 'Flow failed'
            : null,
        });

        const tag = verdict.verdict === 'PASS' ? 'PASS' : 'FAIL';
        console.log(`           ${tag} (${verdict.runId}, ${flowCount} flows)`);
      } catch (e) {
        const err = e instanceof Error ? e.message : String(e);
        results.push({
          name: step.name,
          verdict: 'FAIL',
          runId: null,
          durationMs: Date.now() - stepStart,
          flowCount: 0,
          artifactDir: null,
          error: err,
        });
        console.log(`           FAIL (infrastructure: ${err.slice(0, 80)})`);
      }
    } else if (step.type === 'flutter') {
      try {
        const cwd = resolve(frameworkRoot, step.cwd ?? '.');
        const testPath = step.testPath ?? 'test/';
        const cmd = `flutter test ${testPath} --no-pub`;
        const output = execSync(cmd, {
          cwd,
          encoding: 'utf-8',
          timeout: 180000,
          stdio: ['ignore', 'pipe', 'pipe'],
        });

        const testCount = (output.match(/\+(\d+)/g) ?? []).length;

        results.push({
          name: step.name,
          verdict: 'PASS',
          runId: null,
          durationMs: Date.now() - stepStart,
          flowCount: testCount,
          artifactDir: null,
          error: null,
        });
        console.log(`           PASS`);
      } catch (e) {
        const err = e instanceof Error ? (e as { stderr?: string }).stderr ?? e.message : String(e);
        results.push({
          name: step.name,
          verdict: 'FAIL',
          runId: null,
          durationMs: Date.now() - stepStart,
          flowCount: 0,
          artifactDir: null,
          error: typeof err === 'string' ? err.slice(0, 500) : String(err),
        });
        console.log(`           FAIL`);
      }
    }
  }

  const totalMs = Date.now() - gateStart;
  const overallVerdict = results.every((r) => r.verdict === 'PASS') ? 'PASS' : 'FAIL';

  // Write consolidated report
  const reportDir = resolve(outDir, 'gate');
  if (!existsSync(reportDir)) mkdirSync(reportDir, { recursive: true });
  const reportPath = resolve(reportDir, 'nemyo-gate-report.md');
  const report = generateReport(results, overallVerdict, totalMs);
  writeFileSync(reportPath, report, 'utf-8');

  // Write machine-readable verdict
  const verdictPath = resolve(reportDir, 'gate-verdict.json');
  writeFileSync(
    verdictPath,
    JSON.stringify(
      {
        verdict: overallVerdict,
        timestamp: new Date().toISOString(),
        durationMs: totalMs,
        steps: results.map((r) => ({
          name: r.name,
          verdict: r.verdict,
          runId: r.runId,
          durationMs: r.durationMs,
        })),
      },
      null,
      2,
    ),
    'utf-8',
  );

  console.log(`\n  ── Nemyo Gate: ${overallVerdict} ──`);
  console.log(`  Report: ${reportPath}`);
  console.log(`  Verdict: ${verdictPath}`);
  console.log(`  Duration: ${(totalMs / 1000).toFixed(1)}s\n`);

  process.exit(overallVerdict === 'PASS' ? 0 : 1);
}
